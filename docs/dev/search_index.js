var documenterSearchIndex = {"docs":
[{"location":"Quadrature.html#NumericalAnalysis.NonLinearSolve","page":"数值积分","title":"NumericalAnalysis.NonLinearSolve","text":"","category":"section"},{"location":"Quadrature.html","page":"数值积分","title":"数值积分","text":"Modules = [NumericalAnalysis.Quadrature]\nOrder = [:function] ","category":"page"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals","page":"多项式","title":"NumericalAnalysis.Fundamentals","text":"","category":"section"},{"location":"Fundamentals.html","page":"多项式","title":"多项式","text":"Modules = [Fundamentals]\nOrder = [:type, :function] ","category":"page"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.Polynomial","page":"多项式","title":"NumericalAnalysis.Fundamentals.Polynomial","text":"Polynomial{T}(coe::Vector{<:Real}, roots::Vector{<:Real}) where T <: Real\n\nPolynomial(coe::Vector{<:Real}, roots::Vector{<:Real}=Vector{Int}())\n\n(实)多项式类 \n\np(x)=a_nx^n+a_n-1x^n-1+cdots+a_1x+a_0 quad a_nneq 0\n\n参数\n\nT<:Real : 类型参数, 若没有显式给定, 则隐式地由多项式系数 coe 的元素类型决定. 若显式给出, 可与 coe 的元素类型不一致, 但必须要有 promote_type(T, eltype(coe))==T, 此时将会对 coe 做类型提升处理. \ncoe::Vector{<:Real} : 多项式的系数 a_na_n-1cdotsa_1 a_0, 按幂次降序排列, 并且对于非常数多项式要求 coe[1] 非零, 即最高次项系数不为零. \nroots::Vector{<:Real} : 多项式的根, 默认为(整型)空向量\n\n例子\n\ncoe = [1, 2, 0, 4]              # 系数\np = Polynomial(coe)             # Polynomial(x^3+2x^2+4) \nq = Polynomial{Float64}(coe)    # Polynomial(x^3+2.0x^2+4.0)\n\n\n\n\n\n","category":"type"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.Polynomial-Tuple{Real}","page":"多项式","title":"NumericalAnalysis.Fundamentals.Polynomial","text":"(::Polynomial)(::Real)\n\n将多项式实例变为一个函数, 调用 evaluate 或 qevaluate 计算多项式的值.\n\n例子\n\np = Polynomial(rand(4))\nx = randn()\np(x)  # == evaluate(p, x)\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:*-Tuple{NumericalAnalysis.Fundamentals.Polynomial, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:*","text":"*(::Polynomial, ::Polynomial)\n\n多项式的乘法, 利用快速傅立叶变换.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:*-Tuple{Real, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:*","text":"*(::Real, ::Polynomial)\n\n多项式标量乘法\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:+-Tuple{NumericalAnalysis.Fundamentals.Polynomial, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:+","text":"+(::Polynomial, ::Polynomial)\n\n多项式加法.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:--Tuple{NumericalAnalysis.Fundamentals.Polynomial, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:-","text":"-(::Polynomial, ::Polynomial)\n\n多项式减法.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:--Tuple{NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:-","text":"-(p::Polynomial)\n\n给定多项式 p, 返回其加法逆元 -p.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.:==-Tuple{NumericalAnalysis.Fundamentals.Polynomial, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.:==","text":"==(::Polynomial, ::Polynomial)\n\n通过比较两个多项式的系数向量(值与类型)比较两个多项式是否相等.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.getproperty-Tuple{NumericalAnalysis.Fundamentals.Polynomial, Symbol}","page":"多项式","title":"Base.getproperty","text":"将上面求出的多项式次数作为多项式本身的性质.\n\n例子\n\np = Polynomial([1, 3, 4])\np.degree\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.iszero-Tuple{NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.iszero","text":"iszero(::Polynomial)\n\n判断一个多项式是否为 0 多项式.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"Base.show","text":"show(::io, ::MIME\"text/plain\", ::Polynomial)\n\n输出可视化\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#Base.zero-Union{Tuple{Type{NumericalAnalysis.Fundamentals.Polynomial{T}}}, Tuple{T}} where T<:Real","page":"多项式","title":"Base.zero","text":"zero(::Type{Polynomial{T}}) \n\nzero(::Type{Polynomial})\n\n生成 T 类型的 0 多项式, 若 T 未给出, 则默认为整型.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.degree-Tuple{NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"NumericalAnalysis.Fundamentals.degree","text":"degree(p::Polynomial)::Int\n\n多项式 p 的次数, 0 多项式的次数设为 -1. \n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.evaluate-Tuple{NumericalAnalysis.Fundamentals.Polynomial, Real}","page":"多项式","title":"NumericalAnalysis.Fundamentals.evaluate","text":"evaluate(p::Polynomial, x::Real)\n\n秦九韶算法求多项式值 p(x).\n\n例子\n\np = Polynomial([1, 2, 3, 0, -1])\nevaluate(p, 1.2)\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.from_roots","page":"多项式","title":"NumericalAnalysis.Fundamentals.from_roots","text":"from_roots(roots::Vector{<:Real}, a::Real=1) :: Polynomial\n\n使用根向量 roots 生成多项式, a 为最高次项系数.\n\n例子\n\nroots = [1, 2, 3]\np = from_roots(roots)\n\n\n\n\n\n","category":"function"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.isconstant-Tuple{NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"NumericalAnalysis.Fundamentals.isconstant","text":"isconstant(::Polynomial)\n\n判断一个多项式是否为常多项式.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.qevaluate-Tuple{NumericalAnalysis.Fundamentals.Polynomial, Real}","page":"多项式","title":"NumericalAnalysis.Fundamentals.qevaluate","text":"qevaluate(p::Polynomial, x::Real)\n\n已知多项式 p 的根全为实根, 并且由 p.roots 给出, 使用 Pi_1leqslant kleqslant n(x-x_i) 计算值 p(x), 这里 (x_1x_2cdots x_n)=p.roots, n=p.degree.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals.html#NumericalAnalysis.Fundamentals.∂-Tuple{NumericalAnalysis.Fundamentals.Polynomial}","page":"多项式","title":"NumericalAnalysis.Fundamentals.∂","text":"∂(::Polynomial)\n\n给定一个多项式, 得到其导多项式, 用法为 ∂(p), p 为某一多项式.\n\n\n\n\n\n","category":"method"},{"location":"index.html#NumericalAnalysis.jl","page":"首页","title":"NumericalAnalysis.jl","text":"","category":"section"},{"location":"index.html#简介","page":"首页","title":"简介","text":"","category":"section"},{"location":"index.html","page":"首页","title":"首页","text":"教材 Numerical Analysis (3rd Edition, by Timothy Sauer) 和一些常用数值算法的 Julia 实现. ","category":"page"},{"location":"index.html#多项式","page":"首页","title":"多项式","text":"","category":"section"},{"location":"index.html","page":"首页","title":"首页","text":"Modules=[NumericalAnalysis.Fundamentals]","category":"page"},{"location":"index.html#非线性方程求解","page":"首页","title":"非线性方程求解","text":"","category":"section"},{"location":"index.html","page":"首页","title":"首页","text":"Modules=[NumericalAnalysis.NonLinearSolve]","category":"page"},{"location":"NonLinearSolve.html#NumericalAnalysis.NonLinearSolve","page":"非线性方程求解","title":"NumericalAnalysis.NonLinearSolve","text":"","category":"section"},{"location":"NonLinearSolve.html","page":"非线性方程求解","title":"非线性方程求解","text":"Modules = [NumericalAnalysis.NonLinearSolve]\nOrder = [:function] ","category":"page"},{"location":"NonLinearSolve.html#NumericalAnalysis.NonLinearSolve.bisection","page":"非线性方程求解","title":"NumericalAnalysis.NonLinearSolve.bisection","text":"bisection(func::Function, domain::Tuple{<:Real, <:Real}, ε::Float64=1e-8)\n\n二分法求解函数 func 的位于区间 domain 的根, 停机准则误差为 ε.\n\n\n\n\n\n","category":"function"},{"location":"NonLinearSolve.html#NumericalAnalysis.NonLinearSolve.fixedpoint-Tuple{Function, Real}","page":"非线性方程求解","title":"NumericalAnalysis.NonLinearSolve.fixedpoint","text":"fixedpoint(func::Function, init_point::Real; iter_func::Union{Function, Nothing}=nothing, iter_atol::Float64=1e-8, maxiter::Int=10_000)\n\n不动点迭代求解多项式 func 的根, init_point 为迭代的初始值, iter_func 为迭代函数, 若未给定, 则默认为 x-func(x), iter_atol 为停机准则误差, maxiter 为最大迭代步数.\n\n\n\n\n\n","category":"method"},{"location":"NonLinearSolve.html#NumericalAnalysis.NonLinearSolve.newton-Tuple{Function, Real}","page":"非线性方程求解","title":"NumericalAnalysis.NonLinearSolve.newton","text":"newton(f::Function, x₀::Real; df::Union{Nothing, Function}=nothing, atol::Float64=1e-8, maxiter::Integer=10_000)\n\n牛顿迭代法求解函数 f 的根, x₀ 为迭代的初始值, df 为函数 f 的导函数, 如果没有提供导函数, 就尝试使用符号计算 (Symbolics.jl) 求出导函数, atol 为停机准则误差, maxiter 为最大迭代步数.\n\n\n\n\n\n","category":"method"}]
}
